---
title: "Figure Reproduction for Scientific Reports Paper 24829"  
author: "Joel R Pradines"
date: "`r Sys.Date()`"
output: html_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(patchwork)
library(rJava)
.jinit(classpath = "target/classes")
```

## Figure 1

```{r figure_1_data, echo=TRUE, message=FALSE, warning=FALSE, eval=FALSE}
# Generating figure data
 .jcall("heparansulfate/HIModel", "V", "hepI", "input/", "output/HI/")
 .jcall("heparansulfate/HIModel", "V", "hepIII", "input/", "output/HI/")
```

Figure 1. Distributions of fragment lengths $l$ in heparinase digests (crosses) as compared to distributions
expected under model H&I (dots). Relative abundances are summed for $l ≥ 11$ (heparinase I, (a)) and for $l ≥ 6$
(heparinase III, (b)).

```{r figure1_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=5}
library(ggplot2)
library(patchwork)

plot_figure1_panel <- function(exp_file, model_file, title, threshold, is_hepI = FALSE) {
  # 1. Load and Merge
  df_exp <- read.table(exp_file, header = TRUE)
  df_mod <- read.table(model_file, header = TRUE)
  df_combined <- merge(df_exp, df_mod, by = "l")
  
  # 2. Determine Scale Limits for Panel (b) or use specific for Panel (a)
  # We calculate the range of all data to ensure nothing is cut off
  all_vals <- c(df_combined$f, df_combined$h)
  y_min <- min(all_vals[all_vals > 0]) # Avoid log(0)
  y_max <- max(all_vals)
  
  # 3. Define Labels
  x_labels <- c(as.character(1:(threshold-1)), paste0("≥", threshold))
  
  p <- ggplot(df_combined, aes(x = factor(l))) +
    # Crosses: Consistent size=5, stroke=1
    geom_point(aes(y = f, shape = "Experimental"), size = 5, stroke = 1) +
    # Open Circles: Consistent size=5, stroke=1
    geom_point(aes(y = h, shape = "Model H&I"), size = 5, stroke = 1) +
    
    scale_shape_manual(name = "", values = c("Experimental" = 4, "Model H&I" = 1)) +
    scale_x_discrete(labels = x_labels) +
    labs(title = title, x = "Fragment Length l", y = "Relative Abundance (log scale)") +
    theme_bw() +
    theme(
      legend.position = "bottom",
      panel.grid.minor = element_blank(),
      axis.text = element_text(size = 1),        # Tick labels
      axis.title = element_text(size = 14),       # Axis titles
      plot.title = element_text(size = 16, face = "bold"), # Panel Title
      legend.text = element_text(size = 12)       # Legend Text
    )

  # 4. Apply Specific Y-Axis Logic
  if (is_hepI) {
    # Panel (a) specific: 0.05, 0.1, 0.2, 0.5
    p <- p + scale_y_log10(
      limits = c(0.02, 0.5),
      breaks = c(0.05, 0.1, 0.2, 0.5),
      labels = c("0.05", "0.1", "0.2", "0.5")
    )
  } else {
    # Panel (b) auto-scale: Ensure everything fits with a small buffer
    p <- p + scale_y_log10(
      limits = c(y_min * 0.8, y_max * 1.2),
      breaks = scales::log_breaks(n = 5)
    )
  }
  
  return(p)
}

# File paths
file_exp_hepI <- "input/hepI.f.txt"
file_HIM_hepI <- "output/HI/HIM.hepIhl.res"
file_exp_hepIII <- "input/hepIII.f.txt"
file_HIM_hepIII <- "output/HI/HIM.hepIIIhl.res"

# Generate Panels
p1 <- plot_figure1_panel(file_exp_hepI, file_HIM_hepI, "(a) Heparinase I", 11, is_hepI = TRUE)
p2 <- plot_figure1_panel(file_exp_hepIII, file_HIM_hepIII, "(b) Heparinase III", 6, is_hepI = FALSE)

p1 + p2
```

## Figure 2

Figure 2. Model H&C. Distributions of fragment lengths l in heparinases I (a) and III (b) digests (crosses) as
compared to distributions expected under model H&C (dots). Modeling results are summarized for 100 runs
of optimization with different initial conditions. Transition probabilities of homogeneous Markov models for
H&C (c) and H&I (d).

```{r figure_2_data, echo=TRUE, message=FALSE, warning=FALSE, results='hide', eval=FALSE}
args <- .jarray(character(0), "[Ljava/lang/String;")
# Generating figure data
 .jcall("heparansulfate/HCModelSA", "V", "main", args)
```

```{r figure2_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=10}

# ==============================================================================
# 1. DATA LOADING FUNCTIONS
# ==============================================================================

# --- Function A: Read Fit Results ---
read_and_aggregate_hc_fit <- function(folder_path, pattern) {
  files <- list.files(path = folder_path, pattern = pattern, full.names = TRUE)
  
  if (length(files) == 0) {
     # Return dummy data if files missing (prevents crash during testing)
     warning(paste("No files found for pattern:", pattern))
     return(data.frame(l=1:10, hmod_mean=runif(10,0.01,0.2), hmod_min=0, hmod_max=0.3, fexp=runif(10,0.01,0.2)))
  }
  
  # Read all files
  data_list <- lapply(files, read.table, header = TRUE)
  df_all <- do.call(rbind, data_list)
  
  # Aggregate hmod stats
  stats_agg <- aggregate(hmod ~ l, data = df_all, function(x) c(mean = mean(x), min = min(x), max = max(x)))
  
  df_res <- data.frame(
    l = stats_agg$l,
    hmod_mean = stats_agg$hmod[, "mean"],
    hmod_min  = stats_agg$hmod[, "min"],
    hmod_max  = stats_agg$hmod[, "max"]
  )
  
  # Extract Experimental Data (fexp is constant across files)
  df_exp <- data_list[[1]][, c("l", "fexp")]
  merge(df_res, df_exp, by = "l")
}

# --- Function B: Read H&C Transition Matrices ---
get_hc_matrix <- function(folder_path) {
  files <- list.files(path = folder_path, pattern = "MM\\.s[0-9]+\\.P\\.res", full.names = TRUE)
  
  if (length(files) > 0) {
    tables <- lapply(files, function(f) {
      d <- read.table(f, header = TRUE, col.names = c("prev", "nxt", "p"))
      d$prev <- toupper(d$prev); d$nxt <- toupper(d$nxt)
      return(d)
    })
    
    df_all <- do.call(rbind, tables)
    df_agg <- aggregate(p ~ prev + nxt, data = df_all, mean)
    
    get_p <- function(prev, nxt) {
      val <- df_agg$p[df_agg$prev == prev & df_agg$nxt == nxt]
      if (length(val) == 0) 0 else val
    }
    
    matrix(c(get_p("U","U"), get_p("U","S"), get_p("S","U"), get_p("S","S")), nrow=2, byrow=TRUE)
  } else {
    # Default dummy matrix
    matrix(c(0.53, 0.47, 0.14, 0.86), nrow=2, byrow=TRUE)
  }
}

# --- Function C: Read H&I Matrix ---
get_hi_matrix <- function(file_path = "input/US.ab.txt") {
  if (file.exists(file_path)) {
    df <- read.table(file_path, header = TRUE)
    p_u <- df$rho[toupper(df$name) == "U"]; p_s <- df$rho[toupper(df$name) == "S"]
    
    if (length(p_u) == 0) p_u <- 0; if (length(p_s) == 0) p_s <- 0
    
    matrix(c(p_u, p_s, p_u, p_s), nrow=2, byrow=TRUE) 
  } else {
    matrix(c(0.8642, 0.1358, 0.8642, 0.1358), nrow=2, byrow=TRUE)
  }
}

# ==============================================================================
# 2. PLOTTING FUNCTIONS
# ==============================================================================

# --- Plot Fits (Log Scale) ---
plot_hc_fit_panel <- function(df, title, threshold) {
  x_labs <- as.character(df$l)
  if (max(df$l) == threshold) x_labs[length(x_labs)] <- paste0("≥", threshold)
  
  ggplot(df, aes(x = factor(l))) +
    # Min-Max Interval
    geom_errorbar(aes(ymin = hmod_min, ymax = hmod_max), width = 0.6) +
    
    # Experimental Data (Crosses) - Size increased to 5
    geom_point(aes(y = fexp, shape = "Experimental"), size = 5, stroke = 1) +
    
    # Model Data (Circles) - Size increased to 5
    geom_point(aes(y = hmod_mean, shape = "Model H&C"), size = 5, stroke = 1) +
    
    scale_y_log10() +
    scale_shape_manual(name = "", values = c("Experimental" = 4, "Model H&C" = 1)) +
    scale_x_discrete(labels = x_labs) +
    labs(title = title, x = "Fragment Length l", y = "Relative Abundance (log scale)") +
    theme_bw() +
    theme(
      legend.position = "bottom",
      legend.text = element_text(size = 14),      # Increased Legend Size
      panel.grid.minor = element_blank(),
      axis.text = element_text(size = 14),        # Tick labels (numbers)
      axis.title = element_text(size = 16),       # Axis titles (X/Y labels)
      plot.title = element_text(size = 18, face = "bold") # Panel Title
    )
}

# --- Plot Heatmaps ---
plot_matrix_heatmap <- function(t_mat, title) {
  # Convert matrix to long format for ggplot
  df_mat <- data.frame(
    Prev = rep(c("U", "S"), each = 2),
    Next = rep(c("U", "S"), times = 2),
    Prob = as.vector(t(t_mat)) 
  )
  
  # Ensure factors are ordered U then S
  df_mat$Prev <- factor(df_mat$Prev, levels = c("S", "U")) 
  df_mat$Next <- factor(df_mat$Next, levels = c("U", "S"))

  ggplot(df_mat, aes(x = Next, y = Prev)) +
    geom_tile(aes(fill = Prob), color = "black", size = 1) +
    geom_text(aes(label = sprintf("%.2f", Prob)), size = 8, fontface = "bold") +
    scale_fill_gradient(low = "white", high = "#6baed6", limits = c(0, 1)) +
    scale_x_discrete(position = "top") + 
    labs(
      title = title,
      x = "Next State", 
      y = "Previous State",
      fill = "Probability"
    ) +
    theme_minimal() +
    theme(
      panel.grid = element_blank(),
      legend.position = "none",
      axis.text = element_text(size = 14, face = "bold"),    # Tick labels
      axis.title = element_text(size = 16, face = "bold"),   # Axis titles
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5, margin = margin(b=10)) # Panel Title
    )
}

# ==============================================================================
# 3. EXECUTION
# ==============================================================================

folder_hc <- "output/HC/"

# Load Data
df_fit_hepI   <- read_and_aggregate_hc_fit(folder_hc, "HC\\.s[0-9]+\\.hepI\\.fit\\.res")
df_fit_hepIII <- read_and_aggregate_hc_fit(folder_hc, "HC\\.s[0-9]+\\.hepIII\\.fit\\.res")
mat_hc <- get_hc_matrix(folder_hc)
mat_hi <- get_hi_matrix("input/US.ab.txt")

# Generate Plots
p_a <- plot_hc_fit_panel(df_fit_hepI,   "(a) Heparinase I (Model H&C)", 11)
p_b <- plot_hc_fit_panel(df_fit_hepIII, "(b) Heparinase III (Model H&C)", 6)
p_c <- plot_matrix_heatmap(mat_hc, "(c) Model H&C Transition Matrix")
p_d <- plot_matrix_heatmap(mat_hi, "(d) Model H&I Transition Matrix")

# Layout
(p_a + p_b) / (p_c + p_d)
```

## Figure 3


Figure 3. Model N&I. Distributions of fragment length l in heparinases I (a) and III (b) digests (crosses) as
compared to distributions expected under model N&I (dots). Optimized profiles of S (c) and U (d) proportions
along chains. Modeling results are summarized for 100 runs of optimization with different initial conditions.

```{r figure_3_data, echo=TRUE, message=FALSE, warning=FALSE, results='hide', eval=FALSE}
args <- .jarray(character(0), "[Ljava/lang/String;")
# Generating figure data
 .jcall("heparansulfate/NIModelSA", "V", "main", args)
```

```{r figure_3_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.width=12, fig.height=10}
library(ggplot2)
library(patchwork)

# ==============================================================================
# 1. DATA LOADING FUNCTIONS
# ==============================================================================

# --- Function A: Read Fit Results (Same as Fig 2, adapted for NI) ---
read_ni_fit <- function(folder_path, pattern) {
  files <- list.files(path = folder_path, pattern = pattern, full.names = TRUE)
  
  if (length(files) == 0) {
    # Return dummy data if files missing (prevents crash during testing)
    warning(paste("No files found for pattern:", pattern))
    return(data.frame(l=1:10, hmod_mean=runif(10,0.01,0.1), hmod_min=0, hmod_max=0.2, fexp=runif(10,0.01,0.1)))
  }
  
  # Read all files
  data_list <- lapply(files, read.table, header = TRUE)
  df_all <- do.call(rbind, data_list)
  
  # Aggregate Model Stats (hmod)
  stats <- aggregate(hmod ~ l, data = df_all, function(x) c(mean = mean(x), min = min(x), max = max(x)))
  
  # Create Result Dataframe
  df_res <- data.frame(
    l = stats$l,
    hmod_mean = stats$hmod[, "mean"],
    hmod_min  = stats$hmod[, "min"],
    hmod_max  = stats$hmod[, "max"]
  )
  
  # Extract Experimental Data (fexp is constant across files)
  df_exp <- data_list[[1]][, c("l", "fexp")]
  merge(df_res, df_exp, by = "l")
}

# --- Function B: Read Profile Results (For Panels C & D) ---
read_ni_profiles <- function(folder_path) {
  files <- list.files(path = folder_path, pattern = "PM\\.s[0-9]+\\.gamma\\.res", full.names = TRUE)
  
  if (length(files) == 0) {
    warning("No gamma.res files found.")
    return(data.frame(position=1:16, s_mean=runif(16), s_min=0, s_max=1, u_mean=runif(16), u_min=0, u_max=1))
  }
  
  # Read all files
  data_list <- lapply(files, read.table, header = TRUE)
  df_all <- do.call(rbind, data_list)
  
  # Aggregate S Stats
  stats_s <- aggregate(s ~ position, data = df_all, function(x) c(mean = mean(x), min = min(x), max = max(x)))
  
  # Aggregate U Stats
  stats_u <- aggregate(u ~ position, data = df_all, function(x) c(mean = mean(x), min = min(x), max = max(x)))
  
  # Combine into one dataframe
  data.frame(
    position = stats_s$position,
    s_mean = stats_s$s[, "mean"], s_min = stats_s$s[, "min"], s_max = stats_s$s[, "max"],
    u_mean = stats_u$u[, "mean"], u_min = stats_u$u[, "min"], u_max = stats_u$u[, "max"]
  )
}

# ==============================================================================
# 2. PLOTTING FUNCTIONS
# ==============================================================================

# --- Plot Fits (Log Scale) ---
plot_fit_panel <- function(df, title, threshold) {
  x_labs <- as.character(df$l)
  # Mark the last bin if it's the threshold (e.g. >= 11)
  if (max(df$l) == threshold) x_labs[length(x_labs)] <- paste0("≥", threshold)
  
  ggplot(df, aes(x = factor(l))) +
    # Min-Max Interval
    geom_errorbar(aes(ymin = hmod_min, ymax = hmod_max), width = 0.6) +
    
    # Experimental Data (Crosses)
    geom_point(aes(y = fexp, shape = "Experimental"), size = 5, stroke = 1) +
    
    # Model Data (Circles)
    geom_point(aes(y = hmod_mean, shape = "Model N&I"), size = 5) +
    
    scale_y_log10() +
    scale_shape_manual(name = "", values = c("Experimental" = 4, "Model N&I" = 1)) + 
    scale_x_discrete(labels = x_labs) +
    labs(title = title, x = "Fragment Length l", y = "Relative Abundance (log scale)") +
    theme_bw() +
    theme(legend.position = "bottom", 
          legend.text = element_text(size = 14),
          panel.grid.minor = element_blank(),
          axis.text = element_text(size = 14),        # Tick labels (numbers)
          axis.title = element_text(size = 16),       # Axis titles (X/Y labels)
          plot.title = element_text(size = 18, face = "bold")) # Panel Title
}

# --- Plot Profiles (Linear Scale) ---
plot_profile_panel <- function(df, variable, title) {
  # Select columns dynamically based on 's' or 'u'
  y_mean <- df[[paste0(variable, "_mean")]]
  y_min  <- df[[paste0(variable, "_min")]]
  y_max  <- df[[paste0(variable, "_max")]]
  
  ggplot(df, aes(x = position)) +
    # Error bars for variation
    geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.6, color = "black") +
    
    # Line connecting means
    geom_line(aes(y = y_mean), color = "black", alpha = 0.6) +
    
    # Mean points
    geom_point(aes(y = y_mean), shape = 1, size = 4) +
    
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
    scale_x_continuous(breaks = df$position) + 
    labs(title = title, x = "Position along chain", y = "Probability") +
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          legend.text = element_text(size = 14),
          axis.text = element_text(size = 14),        # Tick labels
          axis.title = element_text(size = 16),       # Axis titles
          plot.title = element_text(size = 18, face = "bold")) # Panel Title
}

# ==============================================================================
# 3. EXECUTION
# ==============================================================================

folder_ni <- "output/NI/"

# Load Data
df_fit_hepI   <- read_ni_fit(folder_ni, "PM\\.s[0-9]+\\.hepI\\.fit\\.res")
df_fit_hepIII <- read_ni_fit(folder_ni, "PM\\.s[0-9]+\\.hepIII\\.fit\\.res")
df_profiles   <- read_ni_profiles(folder_ni)

# Generate Plots
p_a <- plot_fit_panel(df_fit_hepI,   "(a) Heparinase I (Model N&I)", 11)
p_b <- plot_fit_panel(df_fit_hepIII, "(b) Heparinase III (Model N&I)", 6)
p_c <- plot_profile_panel(df_profiles, "s", "(c) Profile of S proportions")
p_d <- plot_profile_panel(df_profiles, "u", "(d) Profile of U proportions")

# Layout: (a+b) on top, (c+d) on bottom
(p_a + p_b) / (p_c + p_d)
```